<!DOCTYPE html>
<html>
<head>
	<script src="physicsjs-full-0.5.3.min.js"></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
	<style>
	* {margin: 0; padding:0;}
	body { width:100%; height:100%; }
	canvas { background:grey; display:block; } 
	</style>
	</head>
	<body>
		<canvas id="viewport" width = "960" height = "580"></canvas>
	</body>
	<script>
 var canvas = document.getElementById('viewport');
 var ctx = canvas.getContext('2d');
 var keysDown = {};

 var laser = function(x,y,s_vx,s_vy){

  return Physics.body('circle', {
        x: x, // x-coordinate
        y: y, // y-coordinate
        vx: vx, // velocity in x-direction
        vy: vy, // velocity in y-direction
        restitution: 0.2,
        radius: 5
 });
}

var ship = function(x,y){
   return Physics.body('ship', {
        x: x, // x-coordinate
        y: y, // y-coordinate
        vx: 0.08, // velocity in x-direction
        vy: 0, // velocity in y-direction
        restitution: 1,
        radius: 20
      });
 }



 var ph = Physics(function(world){

   Physics.body('ship','circle', function(parent){
      return {
        thrust : function(){
          var v = Physics.vector(
              0.15 * Math.cos( this.state.angular.pos ), 
              0.15 * Math.sin( this.state.angular.pos ) 
          );
          this.state.vel = ( v );
          this.state.angular.vel = 0;
        },
        turnr : function(){
          this.state.angular.vel = 0.2 * (Math.PI/180) * -1;
        },
        turnl : function(){
          this.state.angular.vel = 0.2 * (Math.PI/180) * 1;
        },
        destroy : function(){
            var self = this;
        var world = this._world;
        if (!world){
            return self;
        }
        var scratch = Physics.scratchpad();
        var rnd = scratch.vector();
        var pos = this.state.pos;
        var n = 40; // create 40 pieces of debris
        var r = 2 * this.geometry.radius; // circumference
        var size = 8 * r / n; // rough size of debris edges
        var mass = this.mass / n; // mass of debris
        var verts;
        var d;
        var debris = [];

        // create debris
        while ( n-- ){
                // set a random position for the debris (relative to player)
                rnd.set( Math.random() - 0.5, Math.random() - 0.5 ).mult( r );
                d = Physics.body('circle', {
                    x: pos.get(0) + rnd.get(0),
                    y: pos.get(1) + rnd.get(1),
                    radius: 2 + (3 * Math.random()),
                    // velocity of debris is same as player
                    vx: this.state.vel.get(0) * (-1 + (3 * Math.random())),
                    vy: this.state.vel.get(1) * (-1 + (3 * Math.random())),
                    // set a random angular velocity for dramatic effect
                    angularVelocity: (Math.random()-0.5) * 0.06,
                    mass: mass,
                    vertices: verts,
                    // not tooo bouncy
                    restitution: 0.8
                });
                d.gameType = 'debris';
                debris.push( d );
       }

       // remove the debris pulse in 600ms
        setTimeout(function(){
          for (var i = 0, l = debris.length; i < l; ++i)
          {
            world.removeBody( debris[i] );
          }
          debris = undefined;
        }, 1500);

        // add debris
        world.add( debris );
        // remove player
        world.removeBody( this );
        scratch.done();
        return self;
    },
          shoot : function(){
          this.state.angular.vel = 0;
          var self = this;
          var world = this._world;
          if (!world){
              return self;
          }
          var angle = this.state.angular.pos;
          var cos = Math.cos( angle );
          var sin = Math.sin( angle );
          var r = this.geometry.radius + 5;
          var speedConst = 2;
          // create a little circle at the nose of the ship
          // that is traveling at a velocity of 0.5 in the nose direction
          // relative to the ship's current velocity
          var laser = Physics.body('circle', {
              x: this.state.pos.get(0) + r * cos,
              y: this.state.pos.get(1) + r * sin,
              vx: ((0.5 + this.state.vel.get(0)) * cos) * 2,
              vy: ((0.5 + this.state.vel.get(1)) * sin) * 2,
              radius: 5
          });
          // set a custom property for collision purposes
          laser.gameType = 'laser';

          // remove the laser pulse in 600ms
          setTimeout(function(){
              world.removeBody( laser );
              laser = undefined;
          }, 600);
          world.add( laser );
          return self;
        }
      }
   });

   Physics.body('laser','circle', function(parent){
      return {
        destory : function(){
          console.log("DESTROY!");
          world.removeBody(this);
        }
      }
   });


  var viewWidth = canvas.width;
  var viewHeight = canvas.height;
        
  var renderer = Physics.renderer('canvas', {
    el: 'viewport',
    width: viewWidth,
    height: viewHeight,
    meta: false, // don't display meta data
    styles: {
        // set colors for the circle bodies
        'circle' : {
            strokeStyle: 'hsla(60, 37%, 17%, 1)',
            lineWidth: 1,
            fillStyle: 'hsla(60, 37%, 57%, 0.8)',
            angleIndicator: 'hsla(60, 37%, 17%, 0.4)'
        }
    }
  });
  // add the renderer
  world.add( renderer );
  // render on each step
  world.subscribe('step', function(){
    world.render();
  });
  // bounds of the window
  var viewportBounds = Physics.aabb(0, 0, viewWidth, viewHeight);
  // constrain objects to these bounds
  world.add(Physics.behavior('edge-collision-detection', {
      aabb: viewportBounds,
      restitution: 0.99,
      cof: 0.1
  }));

      // If you want to subscribe to collision pairs
      // emit an event for each collision pair
      world.subscribe('collisions:detected', function( data ){
          var c;
          for (var i = 0, l = data.collisions.length; i < l; i++){
              c = data.collisions[ i ];
              world.publish({
                  topic: 'collision-pair',
                  bodyA: c.bodyA,
                  bodyB: c.bodyB
              });
          }
      });

      // subscribe to collision pair
      world.subscribe('collision-pair', function( data ){
          //console.log(data.bodyA.gameType, data.bodyB.gameType);

          if(data.bodyA.gameType == "ship1" || data.bodyB.gameType == "ship1")
          {
            var w = data.bodyA._world;
            w.ship1.destroy();
          }

          if(data.bodyA.gameType == "ship2" || data.bodyB.gameType == "ship2")
          {
            var w = data.bodyA._world;
            w.ship2.destroy();
          }

      });



  world.add( Physics.behavior('body-collision-detection') );
  world.add(Physics.behavior('sweep-prune'));
  // add a circle
  this.ship1 = new ship(50,50);
  this.ship1.gameType = 'ship1';
  world.add(this.ship1);
  this.ship2 = new ship(500,500);
  this.ship2.gameType = 'ship2';
  world.add(this.ship2);
  // ensure objects bounce when edge collision is detected
  world.add( Physics.behavior('body-impulse-response') );
  // add some gravity
  world.add( Physics.behavior('constant-acceleration', {
    acc: { x : 0, y: 0 }
  }) );
 
  // subscribe to ticker to advance the simulation
  Physics.util.ticker.subscribe(function( time, dt ){
      world.step( time );
  });
  // start the ticker
  Physics.util.ticker.start();
});

window.addEventListener('keydown', function(e) {
            keysDown[e.keyCode] = true;
    });
    window.addEventListener('keyup', function(e) {
          // //ship2 stop angular movement when the key is released
          // if(e.keyCode == 37 || e.keyCode == 39)
          // {
          //     ph.ship2.state.angular.vel = 0;
          // }
          // //ship1 stop angular movement when the key is released
          // if(e.keyCode == 65 || e.keyCode == 68)
          // {
          //     ph.ship1.state.angular.vel = 0;
          // }
          delete keysDown[e.keyCode];
    });

  function keyUpdate(){
        var vel = 0.01;
        if (87 in keysDown) {
          ph.ship2.thrust();
        }
        if (65 in keysDown) {
          //angle change towards left 
          ph.ship2.turnr();
        }
        if (68 in keysDown) {
          //angle change towards right
          ph.ship2.turnl();
        }
        if (38 in keysDown) {
          
          ph.ship1.thrust();
        }
        if (37 in keysDown) {
          ph.ship1.turnr();
        }
        if (39 in keysDown) {
          ph.ship1.turnl();
        }
        if (77 in keysDown) {
          ph.ship1.shoot();
        }
        if (90 in keysDown) {
          ph.ship2.shoot();
        }

    }
    //keyUpdate function iteration after every 30 ms.
    setInterval(keyUpdate,30);
	</script>
</html>